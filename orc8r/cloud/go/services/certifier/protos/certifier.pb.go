// Code generated by protoc-gen-go. DO NOT EDIT.
// source: certifier.proto

package protos

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protos "magma/orc8r/lib/go/protos"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type CertificateInfo struct {
	Id                   *protos.Identity     `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	NotBefore            *timestamp.Timestamp `protobuf:"bytes,2,opt,name=not_before,json=notBefore,proto3" json:"not_before,omitempty"`
	NotAfter             *timestamp.Timestamp `protobuf:"bytes,3,opt,name=not_after,json=notAfter,proto3" json:"not_after,omitempty"`
	CertType             protos.CertType      `protobuf:"varint,4,opt,name=cert_type,json=certType,proto3,enum=magma.orc8r.CertType" json:"cert_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *CertificateInfo) Reset()         { *m = CertificateInfo{} }
func (m *CertificateInfo) String() string { return proto.CompactTextString(m) }
func (*CertificateInfo) ProtoMessage()    {}
func (*CertificateInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_515f9a7ba5ef1ab9, []int{0}
}

func (m *CertificateInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CertificateInfo.Unmarshal(m, b)
}
func (m *CertificateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CertificateInfo.Marshal(b, m, deterministic)
}
func (m *CertificateInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateInfo.Merge(m, src)
}
func (m *CertificateInfo) XXX_Size() int {
	return xxx_messageInfo_CertificateInfo.Size(m)
}
func (m *CertificateInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateInfo proto.InternalMessageInfo

func (m *CertificateInfo) GetId() *protos.Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *CertificateInfo) GetNotBefore() *timestamp.Timestamp {
	if m != nil {
		return m.NotBefore
	}
	return nil
}

func (m *CertificateInfo) GetNotAfter() *timestamp.Timestamp {
	if m != nil {
		return m.NotAfter
	}
	return nil
}

func (m *CertificateInfo) GetCertType() protos.CertType {
	if m != nil {
		return m.CertType
	}
	return protos.CertType_DEFAULT
}

type CertificateInfoMap struct {
	Certificates         map[string]*CertificateInfo `protobuf:"bytes,1,rep,name=certificates,proto3" json:"certificates,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *CertificateInfoMap) Reset()         { *m = CertificateInfoMap{} }
func (m *CertificateInfoMap) String() string { return proto.CompactTextString(m) }
func (*CertificateInfoMap) ProtoMessage()    {}
func (*CertificateInfoMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_515f9a7ba5ef1ab9, []int{1}
}

func (m *CertificateInfoMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CertificateInfoMap.Unmarshal(m, b)
}
func (m *CertificateInfoMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CertificateInfoMap.Marshal(b, m, deterministic)
}
func (m *CertificateInfoMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateInfoMap.Merge(m, src)
}
func (m *CertificateInfoMap) XXX_Size() int {
	return xxx_messageInfo_CertificateInfoMap.Size(m)
}
func (m *CertificateInfoMap) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateInfoMap.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateInfoMap proto.InternalMessageInfo

func (m *CertificateInfoMap) GetCertificates() map[string]*CertificateInfo {
	if m != nil {
		return m.Certificates
	}
	return nil
}

type AddCertRequest struct {
	Id                   *protos.Identity `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	CertDer              []byte           `protobuf:"bytes,2,opt,name=cert_der,json=certDer,proto3" json:"cert_der,omitempty"`
	CertType             protos.CertType  `protobuf:"varint,3,opt,name=cert_type,json=certType,proto3,enum=magma.orc8r.CertType" json:"cert_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *AddCertRequest) Reset()         { *m = AddCertRequest{} }
func (m *AddCertRequest) String() string { return proto.CompactTextString(m) }
func (*AddCertRequest) ProtoMessage()    {}
func (*AddCertRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_515f9a7ba5ef1ab9, []int{2}
}

func (m *AddCertRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddCertRequest.Unmarshal(m, b)
}
func (m *AddCertRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddCertRequest.Marshal(b, m, deterministic)
}
func (m *AddCertRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddCertRequest.Merge(m, src)
}
func (m *AddCertRequest) XXX_Size() int {
	return xxx_messageInfo_AddCertRequest.Size(m)
}
func (m *AddCertRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddCertRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddCertRequest proto.InternalMessageInfo

func (m *AddCertRequest) GetId() *protos.Identity {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *AddCertRequest) GetCertDer() []byte {
	if m != nil {
		return m.CertDer
	}
	return nil
}

func (m *AddCertRequest) GetCertType() protos.CertType {
	if m != nil {
		return m.CertType
	}
	return protos.CertType_DEFAULT
}

type SerialNumbers struct {
	Sns                  []string `protobuf:"bytes,1,rep,name=sns,proto3" json:"sns,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SerialNumbers) Reset()         { *m = SerialNumbers{} }
func (m *SerialNumbers) String() string { return proto.CompactTextString(m) }
func (*SerialNumbers) ProtoMessage()    {}
func (*SerialNumbers) Descriptor() ([]byte, []int) {
	return fileDescriptor_515f9a7ba5ef1ab9, []int{3}
}

func (m *SerialNumbers) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SerialNumbers.Unmarshal(m, b)
}
func (m *SerialNumbers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SerialNumbers.Marshal(b, m, deterministic)
}
func (m *SerialNumbers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SerialNumbers.Merge(m, src)
}
func (m *SerialNumbers) XXX_Size() int {
	return xxx_messageInfo_SerialNumbers.Size(m)
}
func (m *SerialNumbers) XXX_DiscardUnknown() {
	xxx_messageInfo_SerialNumbers.DiscardUnknown(m)
}

var xxx_messageInfo_SerialNumbers proto.InternalMessageInfo

func (m *SerialNumbers) GetSns() []string {
	if m != nil {
		return m.Sns
	}
	return nil
}

type GetCARequest struct {
	CertType             protos.CertType `protobuf:"varint,1,opt,name=cert_type,json=certType,proto3,enum=magma.orc8r.CertType" json:"cert_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetCARequest) Reset()         { *m = GetCARequest{} }
func (m *GetCARequest) String() string { return proto.CompactTextString(m) }
func (*GetCARequest) ProtoMessage()    {}
func (*GetCARequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_515f9a7ba5ef1ab9, []int{4}
}

func (m *GetCARequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetCARequest.Unmarshal(m, b)
}
func (m *GetCARequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetCARequest.Marshal(b, m, deterministic)
}
func (m *GetCARequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCARequest.Merge(m, src)
}
func (m *GetCARequest) XXX_Size() int {
	return xxx_messageInfo_GetCARequest.Size(m)
}
func (m *GetCARequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCARequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetCARequest proto.InternalMessageInfo

func (m *GetCARequest) GetCertType() protos.CertType {
	if m != nil {
		return m.CertType
	}
	return protos.CertType_DEFAULT
}

func init() {
	proto.RegisterType((*CertificateInfo)(nil), "magma.orc8r.certifier.CertificateInfo")
	proto.RegisterType((*CertificateInfoMap)(nil), "magma.orc8r.certifier.CertificateInfoMap")
	proto.RegisterMapType((map[string]*CertificateInfo)(nil), "magma.orc8r.certifier.CertificateInfoMap.CertificatesEntry")
	proto.RegisterType((*AddCertRequest)(nil), "magma.orc8r.certifier.AddCertRequest")
	proto.RegisterType((*SerialNumbers)(nil), "magma.orc8r.certifier.SerialNumbers")
	proto.RegisterType((*GetCARequest)(nil), "magma.orc8r.certifier.GetCARequest")
}

func init() { proto.RegisterFile("certifier.proto", fileDescriptor_515f9a7ba5ef1ab9) }

var fileDescriptor_515f9a7ba5ef1ab9 = []byte{
	// 579 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x94, 0xdf, 0x8e, 0xd2, 0x40,
	0x14, 0xc6, 0x5b, 0x90, 0x15, 0x0e, 0xc8, 0xc2, 0x98, 0x4d, 0xba, 0x5d, 0x13, 0xb1, 0xba, 0x06,
	0x6f, 0x4a, 0x82, 0x17, 0xe2, 0x9f, 0x1b, 0xc0, 0x15, 0x37, 0xd9, 0xdd, 0xc4, 0x42, 0xbc, 0xf0,
	0x86, 0x94, 0xf6, 0xd0, 0x4c, 0xb6, 0xed, 0xe0, 0x74, 0xd8, 0x84, 0x17, 0xf0, 0x4d, 0x7c, 0x2d,
	0xe3, 0xa3, 0x98, 0xfe, 0x5b, 0x29, 0x14, 0xed, 0x15, 0x33, 0x73, 0xbe, 0xf9, 0x7d, 0x67, 0xbe,
	0x19, 0x0a, 0xc7, 0x16, 0x72, 0x41, 0x97, 0x14, 0xb9, 0xbe, 0xe2, 0x4c, 0x30, 0x72, 0xe2, 0x99,
	0x8e, 0x67, 0xea, 0x8c, 0x5b, 0x03, 0xae, 0xdf, 0x17, 0xd5, 0x27, 0xd1, 0x42, 0x2f, 0xd2, 0x04,
	0xbd, 0x9d, 0x4d, 0xea, 0x69, 0xb6, 0xca, 0x3c, 0x8f, 0xf9, 0x49, 0xe9, 0x2c, 0x53, 0xa2, 0x36,
	0xfa, 0x82, 0x8a, 0x4d, 0x52, 0x7c, 0xea, 0x30, 0xe6, 0xb8, 0x18, 0x57, 0x17, 0xeb, 0x65, 0x4f,
	0x50, 0x0f, 0x03, 0x61, 0x7a, 0xab, 0x58, 0xa0, 0xfd, 0x96, 0xe1, 0x78, 0x1c, 0x9b, 0x59, 0xa6,
	0xc0, 0x4b, 0x7f, 0xc9, 0xc8, 0x39, 0x94, 0xa8, 0xad, 0xc8, 0x1d, 0xb9, 0x5b, 0xef, 0x9f, 0xe8,
	0xdb, 0xed, 0x5e, 0x26, 0x74, 0xa3, 0x44, 0x6d, 0xf2, 0x16, 0xc0, 0x67, 0x62, 0xbe, 0xc0, 0x25,
	0xe3, 0xa8, 0x94, 0x22, 0xb9, 0xaa, 0xc7, 0x86, 0x7a, 0x6a, 0xa8, 0xcf, 0x52, 0x43, 0xa3, 0xe6,
	0x33, 0x31, 0x8a, 0xc4, 0xe4, 0x0d, 0x84, 0x93, 0xb9, 0xb9, 0x14, 0xc8, 0x95, 0xf2, 0x7f, 0x77,
	0x56, 0x7d, 0x26, 0x86, 0xa1, 0x96, 0xf4, 0xa1, 0x16, 0x46, 0x33, 0x17, 0x9b, 0x15, 0x2a, 0x0f,
	0x3a, 0x72, 0xb7, 0xb9, 0xd3, 0x61, 0x78, 0x96, 0xd9, 0x66, 0x85, 0x46, 0xd5, 0x4a, 0x46, 0xda,
	0x2f, 0x19, 0xc8, 0xce, 0x11, 0xaf, 0xcd, 0x15, 0x99, 0x43, 0xc3, 0xfa, 0xbb, 0x1a, 0x28, 0x72,
	0xa7, 0xdc, 0xad, 0xf7, 0xdf, 0xeb, 0xb9, 0xd7, 0xa3, 0xef, 0x03, 0xb6, 0x97, 0x82, 0x0b, 0x5f,
	0xf0, 0x8d, 0x91, 0x01, 0xaa, 0x0e, 0xb4, 0xf7, 0x24, 0xa4, 0x05, 0xe5, 0x5b, 0xdc, 0x44, 0xe1,
	0xd6, 0x8c, 0x70, 0x48, 0x3e, 0x40, 0xe5, 0xce, 0x74, 0xd7, 0x69, 0x82, 0x2f, 0x8b, 0x35, 0x60,
	0xc4, 0x9b, 0xde, 0x95, 0x06, 0xb2, 0xf6, 0x43, 0x86, 0xe6, 0xd0, 0xb6, 0x43, 0x85, 0x81, 0xdf,
	0xd7, 0x18, 0x88, 0xa2, 0x57, 0x78, 0x0a, 0x51, 0x4c, 0x73, 0x1b, 0x79, 0x64, 0xdf, 0x30, 0x1e,
	0x86, 0xf3, 0x8f, 0xbb, 0x49, 0x97, 0x8b, 0x25, 0xfd, 0x0c, 0x1e, 0x4d, 0x91, 0x53, 0xd3, 0xbd,
	0x59, 0x7b, 0x0b, 0xe4, 0x41, 0x78, 0xda, 0xc0, 0x8f, 0xa3, 0xad, 0x19, 0xe1, 0x50, 0x1b, 0x41,
	0x63, 0x82, 0x62, 0x3c, 0x4c, 0x1b, 0xcd, 0xd8, 0xc8, 0x85, 0x6c, 0xfa, 0x3f, 0x2b, 0x50, 0x1b,
	0xa7, 0xc1, 0x90, 0x31, 0x54, 0x22, 0x22, 0x79, 0x7e, 0x20, 0xb9, 0x6d, 0x3f, 0xf5, 0x71, 0x16,
	0x3e, 0x0c, 0x39, 0x9a, 0x44, 0x46, 0x40, 0xa6, 0xd4, 0xf1, 0x93, 0x14, 0x93, 0x9c, 0x49, 0x2b,
	0x2b, 0x9e, 0x1a, 0xaa, 0xb2, 0xd7, 0x5b, 0xa2, 0xd5, 0x24, 0x32, 0x83, 0xfa, 0x04, 0x45, 0x9a,
	0x2f, 0x39, 0x3b, 0x24, 0xd5, 0xa7, 0x37, 0x6a, 0xc1, 0x5b, 0xd6, 0x24, 0x72, 0x01, 0x6d, 0x03,
	0xef, 0xd8, 0x2d, 0x6e, 0x37, 0xf6, 0x4f, 0x76, 0x3b, 0x53, 0xfc, 0xca, 0xa8, 0xad, 0x49, 0xe4,
	0xea, 0xfe, 0x89, 0xa4, 0x8c, 0xf3, 0x03, 0x2d, 0x64, 0x5f, 0x52, 0x3e, 0xed, 0x0b, 0xb4, 0x3e,
	0x51, 0x7f, 0x1b, 0x17, 0x90, 0xfc, 0x67, 0xa6, 0xbe, 0x38, 0x60, 0x93, 0x79, 0x28, 0x9a, 0x44,
	0xae, 0xa1, 0x75, 0x45, 0x03, 0x91, 0x41, 0xee, 0x7b, 0x17, 0xc6, 0x7d, 0x86, 0xa3, 0x09, 0x8a,
	0xa1, 0xeb, 0xe6, 0x41, 0x5e, 0x15, 0xfe, 0x93, 0x6b, 0x12, 0x19, 0x40, 0x73, 0xcc, 0x5c, 0x17,
	0x2d, 0x31, 0x31, 0xf9, 0xc2, 0x74, 0x30, 0x8f, 0x98, 0x97, 0xd2, 0xa8, 0xfa, 0xed, 0x28, 0xfe,
	0x2a, 0x2f, 0xe2, 0xdf, 0xd7, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xfb, 0xa9, 0xfc, 0xb5, 0x0d,
	0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// CertifierClient is the client API for Certifier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CertifierClient interface {
	// Returns the cert of the requested CA
	GetCA(ctx context.Context, in *GetCARequest, opts ...grpc.CallOption) (*protos.CACert, error)
	// Signs and adds a new certificate to the store.
	// Returns signed certificate.
	//
	SignAddCertificate(ctx context.Context, in *protos.CSR, opts ...grpc.CallOption) (*protos.Certificate, error)
	// Returns the CertificateInfo for a certificate.
	// Throws NOT_FOUND if the certificate is missing.
	//
	GetIdentity(ctx context.Context, in *protos.Certificate_SN, opts ...grpc.CallOption) (*CertificateInfo, error)
	// Revoke an existing certificate.
	// If the certificate does not exist or is expired, this request is ignored.
	//
	RevokeCertificate(ctx context.Context, in *protos.Certificate_SN, opts ...grpc.CallOption) (*protos.Void, error)
	// Add provided Certificate (AddCertRequest.cert_der) into Certifier table and
	// associates its Serial Number with given Identity (AddCertRequest.id)
	AddCertificate(ctx context.Context, in *AddCertRequest, opts ...grpc.CallOption) (*protos.Void, error)
	// Finds & returns Serial Numbers of all Certificates associated with the
	// given Identity
	FindCertificates(ctx context.Context, in *protos.Identity, opts ...grpc.CallOption) (*SerialNumbers, error)
	// Returns serial numbers of all certificates in the table
	ListCertificates(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*SerialNumbers, error)
	// Returns all registered Certificates
	GetAll(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*CertificateInfoMap, error)
	// cleanup expired certificates
	//
	CollectGarbage(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*protos.Void, error)
}

type certifierClient struct {
	cc grpc.ClientConnInterface
}

func NewCertifierClient(cc grpc.ClientConnInterface) CertifierClient {
	return &certifierClient{cc}
}

func (c *certifierClient) GetCA(ctx context.Context, in *GetCARequest, opts ...grpc.CallOption) (*protos.CACert, error) {
	out := new(protos.CACert)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/GetCA", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) SignAddCertificate(ctx context.Context, in *protos.CSR, opts ...grpc.CallOption) (*protos.Certificate, error) {
	out := new(protos.Certificate)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/SignAddCertificate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) GetIdentity(ctx context.Context, in *protos.Certificate_SN, opts ...grpc.CallOption) (*CertificateInfo, error) {
	out := new(CertificateInfo)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/GetIdentity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) RevokeCertificate(ctx context.Context, in *protos.Certificate_SN, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/RevokeCertificate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) AddCertificate(ctx context.Context, in *AddCertRequest, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/AddCertificate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) FindCertificates(ctx context.Context, in *protos.Identity, opts ...grpc.CallOption) (*SerialNumbers, error) {
	out := new(SerialNumbers)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/FindCertificates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) ListCertificates(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*SerialNumbers, error) {
	out := new(SerialNumbers)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/ListCertificates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) GetAll(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*CertificateInfoMap, error) {
	out := new(CertificateInfoMap)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/GetAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *certifierClient) CollectGarbage(ctx context.Context, in *protos.Void, opts ...grpc.CallOption) (*protos.Void, error) {
	out := new(protos.Void)
	err := c.cc.Invoke(ctx, "/magma.orc8r.certifier.Certifier/CollectGarbage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CertifierServer is the server API for Certifier service.
type CertifierServer interface {
	// Returns the cert of the requested CA
	GetCA(context.Context, *GetCARequest) (*protos.CACert, error)
	// Signs and adds a new certificate to the store.
	// Returns signed certificate.
	//
	SignAddCertificate(context.Context, *protos.CSR) (*protos.Certificate, error)
	// Returns the CertificateInfo for a certificate.
	// Throws NOT_FOUND if the certificate is missing.
	//
	GetIdentity(context.Context, *protos.Certificate_SN) (*CertificateInfo, error)
	// Revoke an existing certificate.
	// If the certificate does not exist or is expired, this request is ignored.
	//
	RevokeCertificate(context.Context, *protos.Certificate_SN) (*protos.Void, error)
	// Add provided Certificate (AddCertRequest.cert_der) into Certifier table and
	// associates its Serial Number with given Identity (AddCertRequest.id)
	AddCertificate(context.Context, *AddCertRequest) (*protos.Void, error)
	// Finds & returns Serial Numbers of all Certificates associated with the
	// given Identity
	FindCertificates(context.Context, *protos.Identity) (*SerialNumbers, error)
	// Returns serial numbers of all certificates in the table
	ListCertificates(context.Context, *protos.Void) (*SerialNumbers, error)
	// Returns all registered Certificates
	GetAll(context.Context, *protos.Void) (*CertificateInfoMap, error)
	// cleanup expired certificates
	//
	CollectGarbage(context.Context, *protos.Void) (*protos.Void, error)
}

// UnimplementedCertifierServer can be embedded to have forward compatible implementations.
type UnimplementedCertifierServer struct {
}

func (*UnimplementedCertifierServer) GetCA(ctx context.Context, req *GetCARequest) (*protos.CACert, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCA not implemented")
}
func (*UnimplementedCertifierServer) SignAddCertificate(ctx context.Context, req *protos.CSR) (*protos.Certificate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignAddCertificate not implemented")
}
func (*UnimplementedCertifierServer) GetIdentity(ctx context.Context, req *protos.Certificate_SN) (*CertificateInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIdentity not implemented")
}
func (*UnimplementedCertifierServer) RevokeCertificate(ctx context.Context, req *protos.Certificate_SN) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeCertificate not implemented")
}
func (*UnimplementedCertifierServer) AddCertificate(ctx context.Context, req *AddCertRequest) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCertificate not implemented")
}
func (*UnimplementedCertifierServer) FindCertificates(ctx context.Context, req *protos.Identity) (*SerialNumbers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindCertificates not implemented")
}
func (*UnimplementedCertifierServer) ListCertificates(ctx context.Context, req *protos.Void) (*SerialNumbers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCertificates not implemented")
}
func (*UnimplementedCertifierServer) GetAll(ctx context.Context, req *protos.Void) (*CertificateInfoMap, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (*UnimplementedCertifierServer) CollectGarbage(ctx context.Context, req *protos.Void) (*protos.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CollectGarbage not implemented")
}

func RegisterCertifierServer(s *grpc.Server, srv CertifierServer) {
	s.RegisterService(&_Certifier_serviceDesc, srv)
}

func _Certifier_GetCA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCARequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).GetCA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/GetCA",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).GetCA(ctx, req.(*GetCARequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_SignAddCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.CSR)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).SignAddCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/SignAddCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).SignAddCertificate(ctx, req.(*protos.CSR))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_GetIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Certificate_SN)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).GetIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/GetIdentity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).GetIdentity(ctx, req.(*protos.Certificate_SN))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_RevokeCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Certificate_SN)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).RevokeCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/RevokeCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).RevokeCertificate(ctx, req.(*protos.Certificate_SN))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_AddCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).AddCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/AddCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).AddCertificate(ctx, req.(*AddCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_FindCertificates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).FindCertificates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/FindCertificates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).FindCertificates(ctx, req.(*protos.Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_ListCertificates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).ListCertificates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/ListCertificates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).ListCertificates(ctx, req.(*protos.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_GetAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).GetAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/GetAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).GetAll(ctx, req.(*protos.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Certifier_CollectGarbage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertifierServer).CollectGarbage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.certifier.Certifier/CollectGarbage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertifierServer).CollectGarbage(ctx, req.(*protos.Void))
	}
	return interceptor(ctx, in, info, handler)
}

var _Certifier_serviceDesc = grpc.ServiceDesc{
	ServiceName: "magma.orc8r.certifier.Certifier",
	HandlerType: (*CertifierServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCA",
			Handler:    _Certifier_GetCA_Handler,
		},
		{
			MethodName: "SignAddCertificate",
			Handler:    _Certifier_SignAddCertificate_Handler,
		},
		{
			MethodName: "GetIdentity",
			Handler:    _Certifier_GetIdentity_Handler,
		},
		{
			MethodName: "RevokeCertificate",
			Handler:    _Certifier_RevokeCertificate_Handler,
		},
		{
			MethodName: "AddCertificate",
			Handler:    _Certifier_AddCertificate_Handler,
		},
		{
			MethodName: "FindCertificates",
			Handler:    _Certifier_FindCertificates_Handler,
		},
		{
			MethodName: "ListCertificates",
			Handler:    _Certifier_ListCertificates_Handler,
		},
		{
			MethodName: "GetAll",
			Handler:    _Certifier_GetAll_Handler,
		},
		{
			MethodName: "CollectGarbage",
			Handler:    _Certifier_CollectGarbage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "certifier.proto",
}
