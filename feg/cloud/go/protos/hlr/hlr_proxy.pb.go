// Code generated by protoc-gen-go. DO NOT EDIT.
// source: feg/protos/hlr/hlr_proxy.proto

package hlr

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// This RPC converts Result-Code from Altran MAP Protocol into gRPC status codes
// ErrorCode reflects Experimental-Result values which are 3GPP failures
// to be processed by HLR Proxy.
type ErrorCode int32

const (
	// Default success code
	ErrorCode_SUCCESS                         ErrorCode = 0
	ErrorCode_UNABLE_TO_DELIVER               ErrorCode = 1
	ErrorCode_AUTHENTICATION_REJECTED         ErrorCode = 2
	ErrorCode_AUTHENTICATION_DATA_UNAVAILABLE ErrorCode = 3
	ErrorCode_UNKNOWN_SUBSCRIBER              ErrorCode = 4
	ErrorCode_NO_PATH_TO_HLR                  ErrorCode = 5
	ErrorCode_NO_HLR_IN_ACTIVE_STATE          ErrorCode = 6
	ErrorCode_NO_RESP_FROM_PEER               ErrorCode = 7
)

var ErrorCode_name = map[int32]string{
	0: "SUCCESS",
	1: "UNABLE_TO_DELIVER",
	2: "AUTHENTICATION_REJECTED",
	3: "AUTHENTICATION_DATA_UNAVAILABLE",
	4: "UNKNOWN_SUBSCRIBER",
	5: "NO_PATH_TO_HLR",
	6: "NO_HLR_IN_ACTIVE_STATE",
	7: "NO_RESP_FROM_PEER",
}

var ErrorCode_value = map[string]int32{
	"SUCCESS":                         0,
	"UNABLE_TO_DELIVER":               1,
	"AUTHENTICATION_REJECTED":         2,
	"AUTHENTICATION_DATA_UNAVAILABLE": 3,
	"UNKNOWN_SUBSCRIBER":              4,
	"NO_PATH_TO_HLR":                  5,
	"NO_HLR_IN_ACTIVE_STATE":          6,
	"NO_RESP_FROM_PEER":               7,
}

func (x ErrorCode) String() string {
	return proto.EnumName(ErrorCode_name, int32(x))
}

func (ErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3a4856dd4a1b226e, []int{0}
}

type AuthInfoReq_ResyncInfo_Len int32

const (
	AuthInfoReq_ResyncInfo_ZERO_LEN AuthInfoReq_ResyncInfo_Len = 0
	AuthInfoReq_ResyncInfo_RAND_LEN AuthInfoReq_ResyncInfo_Len = 16
	AuthInfoReq_ResyncInfo_AUTH_LEN AuthInfoReq_ResyncInfo_Len = 16
)

var AuthInfoReq_ResyncInfo_Len_name = map[int32]string{
	0:  "ZERO_LEN",
	16: "RAND_LEN",
	// Duplicate value: 16: "AUTH_LEN",
}

var AuthInfoReq_ResyncInfo_Len_value = map[string]int32{
	"ZERO_LEN": 0,
	"RAND_LEN": 16,
	"AUTH_LEN": 16,
}

func (x AuthInfoReq_ResyncInfo_Len) String() string {
	return proto.EnumName(AuthInfoReq_ResyncInfo_Len_name, int32(x))
}

func (AuthInfoReq_ResyncInfo_Len) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3a4856dd4a1b226e, []int{0, 0, 0}
}

// Authentication Information Request (MAP 29.002 section 8.5.2)
type AuthInfoReq struct {
	// Subscriber identifier
	UserName string `protobuf:"bytes,1,opt,name=user_name,json=userName,proto3" json:"user_name,omitempty"`
	// Number of umts vectors to request in response
	NumRequestedUmtsVectors uint32 `protobuf:"varint,2,opt,name=num_requested_umts_vectors,json=numRequestedUmtsVectors,proto3" json:"num_requested_umts_vectors,omitempty"`
	//ResyncInfo containing RAND and AUTS in the case of a resync attach
	ResyncInfo           *AuthInfoReq_ResyncInfo `protobuf:"bytes,3,opt,name=resync_info,json=resyncInfo,proto3" json:"resync_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *AuthInfoReq) Reset()         { *m = AuthInfoReq{} }
func (m *AuthInfoReq) String() string { return proto.CompactTextString(m) }
func (*AuthInfoReq) ProtoMessage()    {}
func (*AuthInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a4856dd4a1b226e, []int{0}
}

func (m *AuthInfoReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AuthInfoReq.Unmarshal(m, b)
}
func (m *AuthInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AuthInfoReq.Marshal(b, m, deterministic)
}
func (m *AuthInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthInfoReq.Merge(m, src)
}
func (m *AuthInfoReq) XXX_Size() int {
	return xxx_messageInfo_AuthInfoReq.Size(m)
}
func (m *AuthInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_AuthInfoReq proto.InternalMessageInfo

func (m *AuthInfoReq) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *AuthInfoReq) GetNumRequestedUmtsVectors() uint32 {
	if m != nil {
		return m.NumRequestedUmtsVectors
	}
	return 0
}

func (m *AuthInfoReq) GetResyncInfo() *AuthInfoReq_ResyncInfo {
	if m != nil {
		return m.ResyncInfo
	}
	return nil
}

type AuthInfoReq_ResyncInfo struct {
	Rand                 []byte   `protobuf:"bytes,1,opt,name=rand,proto3" json:"rand,omitempty"`
	Autn                 []byte   `protobuf:"bytes,2,opt,name=autn,proto3" json:"autn,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthInfoReq_ResyncInfo) Reset()         { *m = AuthInfoReq_ResyncInfo{} }
func (m *AuthInfoReq_ResyncInfo) String() string { return proto.CompactTextString(m) }
func (*AuthInfoReq_ResyncInfo) ProtoMessage()    {}
func (*AuthInfoReq_ResyncInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a4856dd4a1b226e, []int{0, 0}
}

func (m *AuthInfoReq_ResyncInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AuthInfoReq_ResyncInfo.Unmarshal(m, b)
}
func (m *AuthInfoReq_ResyncInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AuthInfoReq_ResyncInfo.Marshal(b, m, deterministic)
}
func (m *AuthInfoReq_ResyncInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthInfoReq_ResyncInfo.Merge(m, src)
}
func (m *AuthInfoReq_ResyncInfo) XXX_Size() int {
	return xxx_messageInfo_AuthInfoReq_ResyncInfo.Size(m)
}
func (m *AuthInfoReq_ResyncInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthInfoReq_ResyncInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AuthInfoReq_ResyncInfo proto.InternalMessageInfo

func (m *AuthInfoReq_ResyncInfo) GetRand() []byte {
	if m != nil {
		return m.Rand
	}
	return nil
}

func (m *AuthInfoReq_ResyncInfo) GetAutn() []byte {
	if m != nil {
		return m.Autn
	}
	return nil
}

// Authentication Information Answer (MAP 29.002 Section 8.5.2)
type AuthInfoAns struct {
	// EPC error code on failure
	ErrorCode ErrorCode `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3,enum=magma.feg.hlr.ErrorCode" json:"error_code,omitempty"`
	// Authentication vectors matching the requested number
	UmtsVectors          []*AuthInfoAns_UMTSVector `protobuf:"bytes,2,rep,name=umts_vectors,json=umtsVectors,proto3" json:"umts_vectors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *AuthInfoAns) Reset()         { *m = AuthInfoAns{} }
func (m *AuthInfoAns) String() string { return proto.CompactTextString(m) }
func (*AuthInfoAns) ProtoMessage()    {}
func (*AuthInfoAns) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a4856dd4a1b226e, []int{1}
}

func (m *AuthInfoAns) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AuthInfoAns.Unmarshal(m, b)
}
func (m *AuthInfoAns) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AuthInfoAns.Marshal(b, m, deterministic)
}
func (m *AuthInfoAns) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthInfoAns.Merge(m, src)
}
func (m *AuthInfoAns) XXX_Size() int {
	return xxx_messageInfo_AuthInfoAns.Size(m)
}
func (m *AuthInfoAns) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthInfoAns.DiscardUnknown(m)
}

var xxx_messageInfo_AuthInfoAns proto.InternalMessageInfo

func (m *AuthInfoAns) GetErrorCode() ErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return ErrorCode_SUCCESS
}

func (m *AuthInfoAns) GetUmtsVectors() []*AuthInfoAns_UMTSVector {
	if m != nil {
		return m.UmtsVectors
	}
	return nil
}

// For details about fields read 3GPP 33.401
type AuthInfoAns_UMTSVector struct {
	Rand                 []byte   `protobuf:"bytes,1,opt,name=rand,proto3" json:"rand,omitempty"`
	Xres                 []byte   `protobuf:"bytes,2,opt,name=xres,proto3" json:"xres,omitempty"`
	Ck                   []byte   `protobuf:"bytes,3,opt,name=ck,proto3" json:"ck,omitempty"`
	Ik                   []byte   `protobuf:"bytes,4,opt,name=ik,proto3" json:"ik,omitempty"`
	Autn                 []byte   `protobuf:"bytes,5,opt,name=autn,proto3" json:"autn,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthInfoAns_UMTSVector) Reset()         { *m = AuthInfoAns_UMTSVector{} }
func (m *AuthInfoAns_UMTSVector) String() string { return proto.CompactTextString(m) }
func (*AuthInfoAns_UMTSVector) ProtoMessage()    {}
func (*AuthInfoAns_UMTSVector) Descriptor() ([]byte, []int) {
	return fileDescriptor_3a4856dd4a1b226e, []int{1, 0}
}

func (m *AuthInfoAns_UMTSVector) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AuthInfoAns_UMTSVector.Unmarshal(m, b)
}
func (m *AuthInfoAns_UMTSVector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AuthInfoAns_UMTSVector.Marshal(b, m, deterministic)
}
func (m *AuthInfoAns_UMTSVector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthInfoAns_UMTSVector.Merge(m, src)
}
func (m *AuthInfoAns_UMTSVector) XXX_Size() int {
	return xxx_messageInfo_AuthInfoAns_UMTSVector.Size(m)
}
func (m *AuthInfoAns_UMTSVector) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthInfoAns_UMTSVector.DiscardUnknown(m)
}

var xxx_messageInfo_AuthInfoAns_UMTSVector proto.InternalMessageInfo

func (m *AuthInfoAns_UMTSVector) GetRand() []byte {
	if m != nil {
		return m.Rand
	}
	return nil
}

func (m *AuthInfoAns_UMTSVector) GetXres() []byte {
	if m != nil {
		return m.Xres
	}
	return nil
}

func (m *AuthInfoAns_UMTSVector) GetCk() []byte {
	if m != nil {
		return m.Ck
	}
	return nil
}

func (m *AuthInfoAns_UMTSVector) GetIk() []byte {
	if m != nil {
		return m.Ik
	}
	return nil
}

func (m *AuthInfoAns_UMTSVector) GetAutn() []byte {
	if m != nil {
		return m.Autn
	}
	return nil
}

func init() {
	proto.RegisterEnum("magma.feg.hlr.ErrorCode", ErrorCode_name, ErrorCode_value)
	proto.RegisterEnum("magma.feg.hlr.AuthInfoReq_ResyncInfo_Len", AuthInfoReq_ResyncInfo_Len_name, AuthInfoReq_ResyncInfo_Len_value)
	proto.RegisterType((*AuthInfoReq)(nil), "magma.feg.hlr.AuthInfoReq")
	proto.RegisterType((*AuthInfoReq_ResyncInfo)(nil), "magma.feg.hlr.AuthInfoReq.ResyncInfo")
	proto.RegisterType((*AuthInfoAns)(nil), "magma.feg.hlr.AuthInfoAns")
	proto.RegisterType((*AuthInfoAns_UMTSVector)(nil), "magma.feg.hlr.AuthInfoAns.UMTSVector")
}

func init() { proto.RegisterFile("feg/protos/hlr/hlr_proxy.proto", fileDescriptor_3a4856dd4a1b226e) }

var fileDescriptor_3a4856dd4a1b226e = []byte{
	// 560 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x93, 0xcf, 0x6a, 0xdb, 0x40,
	0x10, 0xc6, 0x23, 0x3b, 0x7f, 0xec, 0xb1, 0x13, 0xd4, 0x85, 0x26, 0x46, 0xa1, 0x4d, 0x70, 0x29,
	0x84, 0x1e, 0x64, 0x48, 0x0e, 0x3d, 0xf4, 0xb4, 0x96, 0x37, 0x58, 0xad, 0xb2, 0x32, 0x2b, 0xc9,
	0x85, 0x5c, 0x16, 0x55, 0x5e, 0xff, 0xc1, 0x96, 0x94, 0xac, 0xa4, 0x92, 0xbc, 0x4a, 0x9f, 0xaa,
	0xcf, 0xd3, 0x53, 0xd9, 0x35, 0x8e, 0xd3, 0x40, 0x7a, 0x30, 0x7c, 0xdf, 0xcc, 0x60, 0xcd, 0xf7,
	0x93, 0x06, 0xde, 0x4f, 0xc5, 0xac, 0x77, 0x27, 0xf3, 0x32, 0x2f, 0x7a, 0xf3, 0x95, 0x54, 0x3f,
	0x7e, 0x27, 0xf3, 0x87, 0x47, 0x5b, 0x17, 0xd1, 0x61, 0x1a, 0xcf, 0xd2, 0xd8, 0x9e, 0x8a, 0x99,
	0x3d, 0x5f, 0xc9, 0xee, 0xaf, 0x1a, 0xb4, 0x70, 0x55, 0xce, 0xdd, 0x6c, 0x9a, 0x33, 0x71, 0x8f,
	0x4e, 0xa1, 0x59, 0x15, 0x42, 0xf2, 0x2c, 0x4e, 0x45, 0xc7, 0x38, 0x37, 0x2e, 0x9a, 0xac, 0xa1,
	0x0a, 0x34, 0x4e, 0x05, 0xfa, 0x02, 0x56, 0x56, 0xa5, 0x5c, 0x8a, 0xfb, 0x4a, 0x14, 0xa5, 0x98,
	0xf0, 0x2a, 0x2d, 0x0b, 0xfe, 0x53, 0x24, 0x65, 0x2e, 0x8b, 0x4e, 0xed, 0xdc, 0xb8, 0x38, 0x64,
	0x27, 0x59, 0x95, 0xb2, 0xcd, 0x40, 0x94, 0x96, 0xc5, 0x78, 0xdd, 0x46, 0xd7, 0xd0, 0x92, 0xa2,
	0x78, 0xcc, 0x12, 0xbe, 0xc8, 0xa6, 0x79, 0xa7, 0x7e, 0x6e, 0x5c, 0xb4, 0x2e, 0x3f, 0xda, 0xff,
	0xac, 0x63, 0x3f, 0x5b, 0xc5, 0x66, 0x7a, 0x5a, 0x3b, 0x90, 0x4f, 0xda, 0x5a, 0x00, 0x6c, 0x3b,
	0x08, 0xc1, 0xae, 0x8c, 0xb3, 0x89, 0x5e, 0xb5, 0xcd, 0xb4, 0x56, 0xb5, 0xb8, 0x2a, 0x33, 0xbd,
	0x50, 0x9b, 0x69, 0xdd, 0xbd, 0x82, 0xba, 0x27, 0x32, 0xd4, 0x86, 0xc6, 0x2d, 0x61, 0x3e, 0xf7,
	0x08, 0x35, 0x77, 0x94, 0x63, 0x98, 0x0e, 0xb4, 0x33, 0x95, 0xc3, 0x51, 0x38, 0x5c, 0x3b, 0xab,
	0x66, 0x1a, 0xdd, 0x3f, 0xc6, 0x16, 0x0e, 0xce, 0x0a, 0xf4, 0x19, 0x40, 0x48, 0x99, 0x4b, 0x9e,
	0xe4, 0x93, 0x35, 0x9d, 0xa3, 0xcb, 0xce, 0x8b, 0x04, 0x44, 0x0d, 0x38, 0xf9, 0x44, 0xb0, 0xa6,
	0xd8, 0x48, 0x34, 0x84, 0xf6, 0x0b, 0x54, 0xf5, 0xff, 0x84, 0xc7, 0x59, 0x61, 0x47, 0x37, 0x61,
	0xb0, 0x26, 0xc7, 0x5a, 0xd5, 0x96, 0xa2, 0x35, 0x07, 0xd8, 0xb6, 0x5e, 0x4b, 0xff, 0x20, 0x45,
	0xb1, 0x49, 0xaf, 0x34, 0x3a, 0x82, 0x5a, 0xb2, 0xd4, 0xc8, 0xdb, 0xac, 0x96, 0x2c, 0x95, 0x5f,
	0x2c, 0x3b, 0xbb, 0x6b, 0xbf, 0x58, 0x3e, 0x11, 0xdb, 0xdb, 0x12, 0xfb, 0xf4, 0xdb, 0x80, 0xe6,
	0x53, 0x18, 0xd4, 0x82, 0x83, 0x20, 0x72, 0x1c, 0x12, 0x04, 0xe6, 0x0e, 0x7a, 0x0b, 0x6f, 0x22,
	0x8a, 0xfb, 0x1e, 0xe1, 0xa1, 0xcf, 0x07, 0xc4, 0x73, 0xc7, 0x84, 0x99, 0x06, 0x3a, 0x85, 0x13,
	0x05, 0x90, 0xd0, 0xd0, 0x75, 0x70, 0xe8, 0xfa, 0x94, 0x33, 0xf2, 0x95, 0x38, 0x21, 0x19, 0x98,
	0x35, 0xf4, 0x01, 0xce, 0x5e, 0x34, 0x07, 0x38, 0xc4, 0x3c, 0xa2, 0x78, 0x8c, 0x5d, 0x4f, 0xfd,
	0x99, 0x59, 0x47, 0xc7, 0x80, 0x22, 0xfa, 0x8d, 0xfa, 0xdf, 0x29, 0x0f, 0xa2, 0x7e, 0xe0, 0x30,
	0xb7, 0x4f, 0x98, 0xb9, 0x8b, 0x10, 0x1c, 0x51, 0x9f, 0x8f, 0x70, 0x38, 0x54, 0x4f, 0x1c, 0x7a,
	0xcc, 0xdc, 0x43, 0x16, 0x1c, 0x53, 0xad, 0xb9, 0x4b, 0x39, 0x76, 0x42, 0x77, 0x4c, 0x78, 0x10,
	0xe2, 0x90, 0x98, 0xfb, 0x6a, 0x41, 0xea, 0x73, 0x46, 0x82, 0x11, 0xbf, 0x66, 0xfe, 0x0d, 0x1f,
	0x11, 0xc2, 0xcc, 0x83, 0xcb, 0x11, 0x34, 0x86, 0x2b, 0x39, 0x52, 0xd7, 0x80, 0x06, 0xd0, 0xd8,
	0xf0, 0x46, 0xd6, 0xeb, 0x5f, 0xa1, 0x65, 0xbd, 0xfe, 0x92, 0xba, 0x3b, 0xfd, 0xb3, 0xdb, 0x77,
	0xba, 0xdd, 0x53, 0x57, 0x97, 0xac, 0xf2, 0x6a, 0xd2, 0x9b, 0xe5, 0xcf, 0xce, 0xef, 0xc7, 0xbe,
	0xd6, 0x57, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xb3, 0x97, 0xe8, 0xe2, 0x97, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// HlrProxyClient is the client API for HlrProxy service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type HlrProxyClient interface {
	AuthInfo(ctx context.Context, in *AuthInfoReq, opts ...grpc.CallOption) (*AuthInfoAns, error)
}

type hlrProxyClient struct {
	cc grpc.ClientConnInterface
}

func NewHlrProxyClient(cc grpc.ClientConnInterface) HlrProxyClient {
	return &hlrProxyClient{cc}
}

func (c *hlrProxyClient) AuthInfo(ctx context.Context, in *AuthInfoReq, opts ...grpc.CallOption) (*AuthInfoAns, error) {
	out := new(AuthInfoAns)
	err := c.cc.Invoke(ctx, "/magma.feg.hlr.HlrProxy/AuthInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HlrProxyServer is the server API for HlrProxy service.
type HlrProxyServer interface {
	AuthInfo(context.Context, *AuthInfoReq) (*AuthInfoAns, error)
}

// UnimplementedHlrProxyServer can be embedded to have forward compatible implementations.
type UnimplementedHlrProxyServer struct {
}

func (*UnimplementedHlrProxyServer) AuthInfo(ctx context.Context, req *AuthInfoReq) (*AuthInfoAns, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthInfo not implemented")
}

func RegisterHlrProxyServer(s *grpc.Server, srv HlrProxyServer) {
	s.RegisterService(&_HlrProxy_serviceDesc, srv)
}

func _HlrProxy_AuthInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HlrProxyServer).AuthInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.feg.hlr.HlrProxy/AuthInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HlrProxyServer).AuthInfo(ctx, req.(*AuthInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _HlrProxy_serviceDesc = grpc.ServiceDesc{
	ServiceName: "magma.feg.hlr.HlrProxy",
	HandlerType: (*HlrProxyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AuthInfo",
			Handler:    _HlrProxy_AuthInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "feg/protos/hlr/hlr_proxy.proto",
}
