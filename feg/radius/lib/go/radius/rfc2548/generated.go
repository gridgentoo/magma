// Code generated by radius-dict-gen. DO NOT EDIT.

package rfc2548

import (
	"net"
	"strconv"

	"fbc/lib/go/radius"
	"fbc/lib/go/radius/rfc2865"
)

const (
	MSCHAPResponse_Type             radius.Type = 1
	MSCHAPError_Type                radius.Type = 2
	MSCHAPCPW1_Type                 radius.Type = 3
	MSCHAPCPW2_Type                 radius.Type = 4
	MSCHAPLMEncPW_Type              radius.Type = 5
	MSCHAPNTEncPW_Type              radius.Type = 6
	MSMPPEEncryptionPolicy_Type     radius.Type = 7
	MSMPPEEncryptionType_Type       radius.Type = 8
	MSMPPEEncryptionTypes_Type      radius.Type = 8
	MSRASVendor_Type                radius.Type = 9
	MSCHAPDomain_Type               radius.Type = 10
	MSCHAPChallenge_Type            radius.Type = 11
	MSCHAPMPPEKeys_Type             radius.Type = 12
	MSBAPUsage_Type                 radius.Type = 13
	MSLinkUtilizationThreshold_Type radius.Type = 14
	MSLinkDropTimeLimit_Type        radius.Type = 15
	MSMPPESendKey_Type              radius.Type = 16
	MSMPPERecvKey_Type              radius.Type = 17
	MSRASVersion_Type               radius.Type = 18
	MSOldARAPPassword_Type          radius.Type = 19
	MSNewARAPPassword_Type          radius.Type = 20
	MSARAPPWChangeReason_Type       radius.Type = 21
	MSFilter_Type                   radius.Type = 22
	MSAcctAuthType_Type             radius.Type = 23
	MSAcctEAPType_Type              radius.Type = 24
	MSCHAP2Response_Type            radius.Type = 25
	MSCHAP2Success_Type             radius.Type = 26
	MSCHAP2CPW_Type                 radius.Type = 27
	MSPrimaryDNSServer_Type         radius.Type = 28
	MSSecondaryDNSServer_Type       radius.Type = 29
	MSPrimaryNBNSServer_Type        radius.Type = 30
	MSSecondaryNBNSServer_Type      radius.Type = 31
)

const (
	_Microsoft_VendorID = 311
)

func MSCHAPResponse_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(MSCHAPResponse_Type, a)
	return nil
}

func MSCHAPResponse_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(MSCHAPResponse_Type, a)
	return nil
}

func MSCHAPResponse_Get(p *radius.Packet) (value []byte) {
	value, _ = MSCHAPResponse_Lookup(p)
	return
}

func MSCHAPResponse_GetString(p *radius.Packet) (value string) {
	return string(MSCHAPResponse_Get(p))
}

func MSCHAPResponse_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, attr := range p.Attributes[MSCHAPResponse_Type] {
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAPResponse_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, attr := range p.Attributes[MSCHAPResponse_Type] {
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAPResponse_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(MSCHAPResponse_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func MSCHAPResponse_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(MSCHAPResponse_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func MSCHAPResponse_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(MSCHAPResponse_Type, a)
	return
}

func MSCHAPResponse_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(MSCHAPResponse_Type, a)
	return
}

func MSCHAPError_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(MSCHAPError_Type, a)
	return nil
}

func MSCHAPError_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(MSCHAPError_Type, a)
	return nil
}

func MSCHAPError_Get(p *radius.Packet) (value []byte) {
	value, _ = MSCHAPError_Lookup(p)
	return
}

func MSCHAPError_GetString(p *radius.Packet) (value string) {
	return string(MSCHAPError_Get(p))
}

func MSCHAPError_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, attr := range p.Attributes[MSCHAPError_Type] {
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAPError_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, attr := range p.Attributes[MSCHAPError_Type] {
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAPError_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(MSCHAPError_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func MSCHAPError_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(MSCHAPError_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func MSCHAPError_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(MSCHAPError_Type, a)
	return
}

func MSCHAPError_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(MSCHAPError_Type, a)
	return
}

func MSCHAPCPW1_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(MSCHAPCPW1_Type, a)
	return nil
}

func MSCHAPCPW1_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(MSCHAPCPW1_Type, a)
	return nil
}

func MSCHAPCPW1_Get(p *radius.Packet) (value []byte) {
	value, _ = MSCHAPCPW1_Lookup(p)
	return
}

func MSCHAPCPW1_GetString(p *radius.Packet) (value string) {
	return string(MSCHAPCPW1_Get(p))
}

func MSCHAPCPW1_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, attr := range p.Attributes[MSCHAPCPW1_Type] {
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAPCPW1_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, attr := range p.Attributes[MSCHAPCPW1_Type] {
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAPCPW1_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(MSCHAPCPW1_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func MSCHAPCPW1_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(MSCHAPCPW1_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func MSCHAPCPW1_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(MSCHAPCPW1_Type, a)
	return
}

func MSCHAPCPW1_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(MSCHAPCPW1_Type, a)
	return
}

func MSCHAPCPW2_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(MSCHAPCPW2_Type, a)
	return nil
}

func MSCHAPCPW2_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(MSCHAPCPW2_Type, a)
	return nil
}

func MSCHAPCPW2_Get(p *radius.Packet) (value []byte) {
	value, _ = MSCHAPCPW2_Lookup(p)
	return
}

func MSCHAPCPW2_GetString(p *radius.Packet) (value string) {
	return string(MSCHAPCPW2_Get(p))
}

func MSCHAPCPW2_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, attr := range p.Attributes[MSCHAPCPW2_Type] {
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAPCPW2_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, attr := range p.Attributes[MSCHAPCPW2_Type] {
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAPCPW2_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(MSCHAPCPW2_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func MSCHAPCPW2_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(MSCHAPCPW2_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func MSCHAPCPW2_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(MSCHAPCPW2_Type, a)
	return
}

func MSCHAPCPW2_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(MSCHAPCPW2_Type, a)
	return
}

func MSCHAPLMEncPW_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(MSCHAPLMEncPW_Type, a)
	return nil
}

func MSCHAPLMEncPW_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(MSCHAPLMEncPW_Type, a)
	return nil
}

func MSCHAPLMEncPW_Get(p *radius.Packet) (value []byte) {
	value, _ = MSCHAPLMEncPW_Lookup(p)
	return
}

func MSCHAPLMEncPW_GetString(p *radius.Packet) (value string) {
	return string(MSCHAPLMEncPW_Get(p))
}

func MSCHAPLMEncPW_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, attr := range p.Attributes[MSCHAPLMEncPW_Type] {
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAPLMEncPW_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, attr := range p.Attributes[MSCHAPLMEncPW_Type] {
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAPLMEncPW_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(MSCHAPLMEncPW_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func MSCHAPLMEncPW_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(MSCHAPLMEncPW_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func MSCHAPLMEncPW_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(MSCHAPLMEncPW_Type, a)
	return
}

func MSCHAPLMEncPW_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(MSCHAPLMEncPW_Type, a)
	return
}

func MSCHAPNTEncPW_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(MSCHAPNTEncPW_Type, a)
	return nil
}

func MSCHAPNTEncPW_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(MSCHAPNTEncPW_Type, a)
	return nil
}

func MSCHAPNTEncPW_Get(p *radius.Packet) (value []byte) {
	value, _ = MSCHAPNTEncPW_Lookup(p)
	return
}

func MSCHAPNTEncPW_GetString(p *radius.Packet) (value string) {
	return string(MSCHAPNTEncPW_Get(p))
}

func MSCHAPNTEncPW_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, attr := range p.Attributes[MSCHAPNTEncPW_Type] {
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAPNTEncPW_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, attr := range p.Attributes[MSCHAPNTEncPW_Type] {
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAPNTEncPW_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(MSCHAPNTEncPW_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func MSCHAPNTEncPW_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(MSCHAPNTEncPW_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func MSCHAPNTEncPW_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(MSCHAPNTEncPW_Type, a)
	return
}

func MSCHAPNTEncPW_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(MSCHAPNTEncPW_Type, a)
	return
}

func MSMPPEEncryptionPolicy_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(MSMPPEEncryptionPolicy_Type, a)
	return nil
}

func MSMPPEEncryptionPolicy_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(MSMPPEEncryptionPolicy_Type, a)
	return nil
}

func MSMPPEEncryptionPolicy_Get(p *radius.Packet) (value []byte) {
	value, _ = MSMPPEEncryptionPolicy_Lookup(p)
	return
}

func MSMPPEEncryptionPolicy_GetString(p *radius.Packet) (value string) {
	return string(MSMPPEEncryptionPolicy_Get(p))
}

func MSMPPEEncryptionPolicy_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, attr := range p.Attributes[MSMPPEEncryptionPolicy_Type] {
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSMPPEEncryptionPolicy_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, attr := range p.Attributes[MSMPPEEncryptionPolicy_Type] {
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSMPPEEncryptionPolicy_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(MSMPPEEncryptionPolicy_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func MSMPPEEncryptionPolicy_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(MSMPPEEncryptionPolicy_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func MSMPPEEncryptionPolicy_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(MSMPPEEncryptionPolicy_Type, a)
	return
}

func MSMPPEEncryptionPolicy_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(MSMPPEEncryptionPolicy_Type, a)
	return
}

func MSMPPEEncryptionType_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(MSMPPEEncryptionType_Type, a)
	return nil
}

func MSMPPEEncryptionType_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(MSMPPEEncryptionType_Type, a)
	return nil
}

func MSMPPEEncryptionType_Get(p *radius.Packet) (value []byte) {
	value, _ = MSMPPEEncryptionType_Lookup(p)
	return
}

func MSMPPEEncryptionType_GetString(p *radius.Packet) (value string) {
	return string(MSMPPEEncryptionType_Get(p))
}

func MSMPPEEncryptionType_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, attr := range p.Attributes[MSMPPEEncryptionType_Type] {
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSMPPEEncryptionType_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, attr := range p.Attributes[MSMPPEEncryptionType_Type] {
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSMPPEEncryptionType_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(MSMPPEEncryptionType_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func MSMPPEEncryptionType_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(MSMPPEEncryptionType_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func MSMPPEEncryptionType_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(MSMPPEEncryptionType_Type, a)
	return
}

func MSMPPEEncryptionType_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(MSMPPEEncryptionType_Type, a)
	return
}

func MSMPPEEncryptionTypes_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(MSMPPEEncryptionTypes_Type, a)
	return nil
}

func MSMPPEEncryptionTypes_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(MSMPPEEncryptionTypes_Type, a)
	return nil
}

func MSMPPEEncryptionTypes_Get(p *radius.Packet) (value []byte) {
	value, _ = MSMPPEEncryptionTypes_Lookup(p)
	return
}

func MSMPPEEncryptionTypes_GetString(p *radius.Packet) (value string) {
	return string(MSMPPEEncryptionTypes_Get(p))
}

func MSMPPEEncryptionTypes_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, attr := range p.Attributes[MSMPPEEncryptionTypes_Type] {
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSMPPEEncryptionTypes_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, attr := range p.Attributes[MSMPPEEncryptionTypes_Type] {
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSMPPEEncryptionTypes_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(MSMPPEEncryptionTypes_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func MSMPPEEncryptionTypes_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(MSMPPEEncryptionTypes_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func MSMPPEEncryptionTypes_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(MSMPPEEncryptionTypes_Type, a)
	return
}

func MSMPPEEncryptionTypes_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(MSMPPEEncryptionTypes_Type, a)
	return
}

type MSRASVendor uint32

var MSRASVendor_Strings = map[MSRASVendor]string{}

func (a MSRASVendor) String() string {
	if str, ok := MSRASVendor_Strings[a]; ok {
		return str
	}
	return "MSRASVendor(" + strconv.FormatUint(uint64(a), 10) + ")"
}

func MSRASVendor_Add(p *radius.Packet, value MSRASVendor) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Add(MSRASVendor_Type, a)
	return nil
}

func MSRASVendor_Get(p *radius.Packet) (value MSRASVendor) {
	value, _ = MSRASVendor_Lookup(p)
	return
}

func MSRASVendor_Gets(p *radius.Packet) (values []MSRASVendor, err error) {
	var i uint32
	for _, attr := range p.Attributes[MSRASVendor_Type] {
		i, err = radius.Integer(attr)
		if err != nil {
			return
		}
		values = append(values, MSRASVendor(i))
	}
	return
}

func MSRASVendor_Lookup(p *radius.Packet) (value MSRASVendor, err error) {
	a, ok := p.Lookup(MSRASVendor_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	var i uint32
	i, err = radius.Integer(a)
	if err != nil {
		return
	}
	value = MSRASVendor(i)
	return
}

func MSRASVendor_Set(p *radius.Packet, value MSRASVendor) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Set(MSRASVendor_Type, a)
	return nil
}

func MSCHAPDomain_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(MSCHAPDomain_Type, a)
	return nil
}

func MSCHAPDomain_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(MSCHAPDomain_Type, a)
	return nil
}

func MSCHAPDomain_Get(p *radius.Packet) (value []byte) {
	value, _ = MSCHAPDomain_Lookup(p)
	return
}

func MSCHAPDomain_GetString(p *radius.Packet) (value string) {
	return string(MSCHAPDomain_Get(p))
}

func MSCHAPDomain_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, attr := range p.Attributes[MSCHAPDomain_Type] {
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAPDomain_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, attr := range p.Attributes[MSCHAPDomain_Type] {
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAPDomain_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(MSCHAPDomain_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func MSCHAPDomain_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(MSCHAPDomain_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func MSCHAPDomain_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(MSCHAPDomain_Type, a)
	return
}

func MSCHAPDomain_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(MSCHAPDomain_Type, a)
	return
}

func MSCHAPChallenge_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(MSCHAPChallenge_Type, a)
	return nil
}

func MSCHAPChallenge_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(MSCHAPChallenge_Type, a)
	return nil
}

func MSCHAPChallenge_Get(p *radius.Packet) (value []byte) {
	value, _ = MSCHAPChallenge_Lookup(p)
	return
}

func MSCHAPChallenge_GetString(p *radius.Packet) (value string) {
	return string(MSCHAPChallenge_Get(p))
}

func MSCHAPChallenge_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, attr := range p.Attributes[MSCHAPChallenge_Type] {
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAPChallenge_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, attr := range p.Attributes[MSCHAPChallenge_Type] {
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAPChallenge_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(MSCHAPChallenge_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func MSCHAPChallenge_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(MSCHAPChallenge_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func MSCHAPChallenge_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(MSCHAPChallenge_Type, a)
	return
}

func MSCHAPChallenge_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(MSCHAPChallenge_Type, a)
	return
}

func MSCHAPMPPEKeys_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(MSCHAPMPPEKeys_Type, a)
	return nil
}

func MSCHAPMPPEKeys_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(MSCHAPMPPEKeys_Type, a)
	return nil
}

func MSCHAPMPPEKeys_Get(p *radius.Packet) (value []byte) {
	value, _ = MSCHAPMPPEKeys_Lookup(p)
	return
}

func MSCHAPMPPEKeys_GetString(p *radius.Packet) (value string) {
	return string(MSCHAPMPPEKeys_Get(p))
}

func MSCHAPMPPEKeys_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, attr := range p.Attributes[MSCHAPMPPEKeys_Type] {
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAPMPPEKeys_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, attr := range p.Attributes[MSCHAPMPPEKeys_Type] {
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAPMPPEKeys_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(MSCHAPMPPEKeys_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func MSCHAPMPPEKeys_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(MSCHAPMPPEKeys_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func MSCHAPMPPEKeys_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(MSCHAPMPPEKeys_Type, a)
	return
}

func MSCHAPMPPEKeys_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(MSCHAPMPPEKeys_Type, a)
	return
}

type MSBAPUsage uint32

const (
	MSBAPUsage_Value_NotAllowed MSBAPUsage = 0
	MSBAPUsage_Value_Allowed    MSBAPUsage = 1
	MSBAPUsage_Value_Required   MSBAPUsage = 2
)

var MSBAPUsage_Strings = map[MSBAPUsage]string{
	MSBAPUsage_Value_NotAllowed: "Not-Allowed",
	MSBAPUsage_Value_Allowed:    "Allowed",
	MSBAPUsage_Value_Required:   "Required",
}

func (a MSBAPUsage) String() string {
	if str, ok := MSBAPUsage_Strings[a]; ok {
		return str
	}
	return "MSBAPUsage(" + strconv.FormatUint(uint64(a), 10) + ")"
}

func MSBAPUsage_Add(p *radius.Packet, value MSBAPUsage) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Add(MSBAPUsage_Type, a)
	return nil
}

func MSBAPUsage_Get(p *radius.Packet) (value MSBAPUsage) {
	value, _ = MSBAPUsage_Lookup(p)
	return
}

func MSBAPUsage_Gets(p *radius.Packet) (values []MSBAPUsage, err error) {
	var i uint32
	for _, attr := range p.Attributes[MSBAPUsage_Type] {
		i, err = radius.Integer(attr)
		if err != nil {
			return
		}
		values = append(values, MSBAPUsage(i))
	}
	return
}

func MSBAPUsage_Lookup(p *radius.Packet) (value MSBAPUsage, err error) {
	a, ok := p.Lookup(MSBAPUsage_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	var i uint32
	i, err = radius.Integer(a)
	if err != nil {
		return
	}
	value = MSBAPUsage(i)
	return
}

func MSBAPUsage_Set(p *radius.Packet, value MSBAPUsage) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Set(MSBAPUsage_Type, a)
	return nil
}

type MSLinkUtilizationThreshold uint32

var MSLinkUtilizationThreshold_Strings = map[MSLinkUtilizationThreshold]string{}

func (a MSLinkUtilizationThreshold) String() string {
	if str, ok := MSLinkUtilizationThreshold_Strings[a]; ok {
		return str
	}
	return "MSLinkUtilizationThreshold(" + strconv.FormatUint(uint64(a), 10) + ")"
}

func MSLinkUtilizationThreshold_Add(p *radius.Packet, value MSLinkUtilizationThreshold) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Add(MSLinkUtilizationThreshold_Type, a)
	return nil
}

func MSLinkUtilizationThreshold_Get(p *radius.Packet) (value MSLinkUtilizationThreshold) {
	value, _ = MSLinkUtilizationThreshold_Lookup(p)
	return
}

func MSLinkUtilizationThreshold_Gets(p *radius.Packet) (values []MSLinkUtilizationThreshold, err error) {
	var i uint32
	for _, attr := range p.Attributes[MSLinkUtilizationThreshold_Type] {
		i, err = radius.Integer(attr)
		if err != nil {
			return
		}
		values = append(values, MSLinkUtilizationThreshold(i))
	}
	return
}

func MSLinkUtilizationThreshold_Lookup(p *radius.Packet) (value MSLinkUtilizationThreshold, err error) {
	a, ok := p.Lookup(MSLinkUtilizationThreshold_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	var i uint32
	i, err = radius.Integer(a)
	if err != nil {
		return
	}
	value = MSLinkUtilizationThreshold(i)
	return
}

func MSLinkUtilizationThreshold_Set(p *radius.Packet, value MSLinkUtilizationThreshold) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Set(MSLinkUtilizationThreshold_Type, a)
	return nil
}

type MSLinkDropTimeLimit uint32

var MSLinkDropTimeLimit_Strings = map[MSLinkDropTimeLimit]string{}

func (a MSLinkDropTimeLimit) String() string {
	if str, ok := MSLinkDropTimeLimit_Strings[a]; ok {
		return str
	}
	return "MSLinkDropTimeLimit(" + strconv.FormatUint(uint64(a), 10) + ")"
}

func MSLinkDropTimeLimit_Add(p *radius.Packet, value MSLinkDropTimeLimit) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Add(MSLinkDropTimeLimit_Type, a)
	return nil
}

func MSLinkDropTimeLimit_Get(p *radius.Packet) (value MSLinkDropTimeLimit) {
	value, _ = MSLinkDropTimeLimit_Lookup(p)
	return
}

func MSLinkDropTimeLimit_Gets(p *radius.Packet) (values []MSLinkDropTimeLimit, err error) {
	var i uint32
	for _, attr := range p.Attributes[MSLinkDropTimeLimit_Type] {
		i, err = radius.Integer(attr)
		if err != nil {
			return
		}
		values = append(values, MSLinkDropTimeLimit(i))
	}
	return
}

func MSLinkDropTimeLimit_Lookup(p *radius.Packet) (value MSLinkDropTimeLimit, err error) {
	a, ok := p.Lookup(MSLinkDropTimeLimit_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	var i uint32
	i, err = radius.Integer(a)
	if err != nil {
		return
	}
	value = MSLinkDropTimeLimit(i)
	return
}

func MSLinkDropTimeLimit_Set(p *radius.Packet, value MSLinkDropTimeLimit) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Set(MSLinkDropTimeLimit_Type, a)
	return nil
}

func MSMPPESendKey_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(MSMPPESendKey_Type, a)
	return nil
}

func MSMPPESendKey_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(MSMPPESendKey_Type, a)
	return nil
}

func MSMPPESendKey_Get(p *radius.Packet) (value []byte) {
	value, _ = MSMPPESendKey_Lookup(p)
	return
}

func MSMPPESendKey_GetString(p *radius.Packet) (value string) {
	return string(MSMPPESendKey_Get(p))
}

func MSMPPESendKey_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, attr := range p.Attributes[MSMPPESendKey_Type] {
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSMPPESendKey_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, attr := range p.Attributes[MSMPPESendKey_Type] {
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSMPPESendKey_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(MSMPPESendKey_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func MSMPPESendKey_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(MSMPPESendKey_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func MSMPPESendKey_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(MSMPPESendKey_Type, a)
	return
}

func MSMPPESendKey_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(MSMPPESendKey_Type, a)
	return
}

func MSMPPERecvKey_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(MSMPPERecvKey_Type, a)
	return nil
}

func MSMPPERecvKey_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(MSMPPERecvKey_Type, a)
	return nil
}

func MSMPPERecvKey_Get(p *radius.Packet) (value []byte) {
	value, _ = MSMPPERecvKey_Lookup(p)
	return
}

func MSMPPERecvKey_GetString(p *radius.Packet) (value string) {
	return string(MSMPPERecvKey_Get(p))
}

func MSMPPERecvKey_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, attr := range p.Attributes[MSMPPERecvKey_Type] {
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSMPPERecvKey_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, attr := range p.Attributes[MSMPPERecvKey_Type] {
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSMPPERecvKey_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(MSMPPERecvKey_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func MSMPPERecvKey_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(MSMPPERecvKey_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func MSMPPERecvKey_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(MSMPPERecvKey_Type, a)
	return
}

func MSMPPERecvKey_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(MSMPPERecvKey_Type, a)
	return
}

func MSRASVersion_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(MSRASVersion_Type, a)
	return nil
}

func MSRASVersion_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(MSRASVersion_Type, a)
	return nil
}

func MSRASVersion_Get(p *radius.Packet) (value []byte) {
	value, _ = MSRASVersion_Lookup(p)
	return
}

func MSRASVersion_GetString(p *radius.Packet) (value string) {
	return string(MSRASVersion_Get(p))
}

func MSRASVersion_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, attr := range p.Attributes[MSRASVersion_Type] {
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSRASVersion_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, attr := range p.Attributes[MSRASVersion_Type] {
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSRASVersion_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(MSRASVersion_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func MSRASVersion_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(MSRASVersion_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func MSRASVersion_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(MSRASVersion_Type, a)
	return
}

func MSRASVersion_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(MSRASVersion_Type, a)
	return
}

func MSOldARAPPassword_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(MSOldARAPPassword_Type, a)
	return nil
}

func MSOldARAPPassword_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(MSOldARAPPassword_Type, a)
	return nil
}

func MSOldARAPPassword_Get(p *radius.Packet) (value []byte) {
	value, _ = MSOldARAPPassword_Lookup(p)
	return
}

func MSOldARAPPassword_GetString(p *radius.Packet) (value string) {
	return string(MSOldARAPPassword_Get(p))
}

func MSOldARAPPassword_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, attr := range p.Attributes[MSOldARAPPassword_Type] {
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSOldARAPPassword_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, attr := range p.Attributes[MSOldARAPPassword_Type] {
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSOldARAPPassword_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(MSOldARAPPassword_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func MSOldARAPPassword_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(MSOldARAPPassword_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func MSOldARAPPassword_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(MSOldARAPPassword_Type, a)
	return
}

func MSOldARAPPassword_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(MSOldARAPPassword_Type, a)
	return
}

func MSNewARAPPassword_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(MSNewARAPPassword_Type, a)
	return nil
}

func MSNewARAPPassword_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(MSNewARAPPassword_Type, a)
	return nil
}

func MSNewARAPPassword_Get(p *radius.Packet) (value []byte) {
	value, _ = MSNewARAPPassword_Lookup(p)
	return
}

func MSNewARAPPassword_GetString(p *radius.Packet) (value string) {
	return string(MSNewARAPPassword_Get(p))
}

func MSNewARAPPassword_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, attr := range p.Attributes[MSNewARAPPassword_Type] {
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSNewARAPPassword_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, attr := range p.Attributes[MSNewARAPPassword_Type] {
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSNewARAPPassword_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(MSNewARAPPassword_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func MSNewARAPPassword_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(MSNewARAPPassword_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func MSNewARAPPassword_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(MSNewARAPPassword_Type, a)
	return
}

func MSNewARAPPassword_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(MSNewARAPPassword_Type, a)
	return
}

type MSARAPPWChangeReason uint32

const (
	MSARAPPWChangeReason_Value_JustChangePassword          MSARAPPWChangeReason = 1
	MSARAPPWChangeReason_Value_ExpiredPassword             MSARAPPWChangeReason = 2
	MSARAPPWChangeReason_Value_AdminRequiresPasswordChange MSARAPPWChangeReason = 3
	MSARAPPWChangeReason_Value_PasswordTooShort            MSARAPPWChangeReason = 4
)

var MSARAPPWChangeReason_Strings = map[MSARAPPWChangeReason]string{
	MSARAPPWChangeReason_Value_JustChangePassword:          "Just-Change-Password",
	MSARAPPWChangeReason_Value_ExpiredPassword:             "Expired-Password",
	MSARAPPWChangeReason_Value_AdminRequiresPasswordChange: "Admin-Requires-Password-Change",
	MSARAPPWChangeReason_Value_PasswordTooShort:            "Password-Too-Short",
}

func (a MSARAPPWChangeReason) String() string {
	if str, ok := MSARAPPWChangeReason_Strings[a]; ok {
		return str
	}
	return "MSARAPPWChangeReason(" + strconv.FormatUint(uint64(a), 10) + ")"
}

func MSARAPPWChangeReason_Add(p *radius.Packet, value MSARAPPWChangeReason) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Add(MSARAPPWChangeReason_Type, a)
	return nil
}

func MSARAPPWChangeReason_Get(p *radius.Packet) (value MSARAPPWChangeReason) {
	value, _ = MSARAPPWChangeReason_Lookup(p)
	return
}

func MSARAPPWChangeReason_Gets(p *radius.Packet) (values []MSARAPPWChangeReason, err error) {
	var i uint32
	for _, attr := range p.Attributes[MSARAPPWChangeReason_Type] {
		i, err = radius.Integer(attr)
		if err != nil {
			return
		}
		values = append(values, MSARAPPWChangeReason(i))
	}
	return
}

func MSARAPPWChangeReason_Lookup(p *radius.Packet) (value MSARAPPWChangeReason, err error) {
	a, ok := p.Lookup(MSARAPPWChangeReason_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	var i uint32
	i, err = radius.Integer(a)
	if err != nil {
		return
	}
	value = MSARAPPWChangeReason(i)
	return
}

func MSARAPPWChangeReason_Set(p *radius.Packet, value MSARAPPWChangeReason) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Set(MSARAPPWChangeReason_Type, a)
	return nil
}

func MSFilter_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(MSFilter_Type, a)
	return nil
}

func MSFilter_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(MSFilter_Type, a)
	return nil
}

func MSFilter_Get(p *radius.Packet) (value []byte) {
	value, _ = MSFilter_Lookup(p)
	return
}

func MSFilter_GetString(p *radius.Packet) (value string) {
	return string(MSFilter_Get(p))
}

func MSFilter_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, attr := range p.Attributes[MSFilter_Type] {
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSFilter_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, attr := range p.Attributes[MSFilter_Type] {
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSFilter_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(MSFilter_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func MSFilter_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(MSFilter_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func MSFilter_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(MSFilter_Type, a)
	return
}

func MSFilter_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(MSFilter_Type, a)
	return
}

type MSAcctAuthType uint32

const (
	MSAcctAuthType_Value_PAP     MSAcctAuthType = 1
	MSAcctAuthType_Value_CHAP    MSAcctAuthType = 2
	MSAcctAuthType_Value_MSCHAP1 MSAcctAuthType = 3
	MSAcctAuthType_Value_MSCHAP2 MSAcctAuthType = 4
	MSAcctAuthType_Value_EAP     MSAcctAuthType = 5
)

var MSAcctAuthType_Strings = map[MSAcctAuthType]string{
	MSAcctAuthType_Value_PAP:     "PAP",
	MSAcctAuthType_Value_CHAP:    "CHAP",
	MSAcctAuthType_Value_MSCHAP1: "MS-CHAP-1",
	MSAcctAuthType_Value_MSCHAP2: "MS-CHAP-2",
	MSAcctAuthType_Value_EAP:     "EAP",
}

func (a MSAcctAuthType) String() string {
	if str, ok := MSAcctAuthType_Strings[a]; ok {
		return str
	}
	return "MSAcctAuthType(" + strconv.FormatUint(uint64(a), 10) + ")"
}

func MSAcctAuthType_Add(p *radius.Packet, value MSAcctAuthType) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Add(MSAcctAuthType_Type, a)
	return nil
}

func MSAcctAuthType_Get(p *radius.Packet) (value MSAcctAuthType) {
	value, _ = MSAcctAuthType_Lookup(p)
	return
}

func MSAcctAuthType_Gets(p *radius.Packet) (values []MSAcctAuthType, err error) {
	var i uint32
	for _, attr := range p.Attributes[MSAcctAuthType_Type] {
		i, err = radius.Integer(attr)
		if err != nil {
			return
		}
		values = append(values, MSAcctAuthType(i))
	}
	return
}

func MSAcctAuthType_Lookup(p *radius.Packet) (value MSAcctAuthType, err error) {
	a, ok := p.Lookup(MSAcctAuthType_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	var i uint32
	i, err = radius.Integer(a)
	if err != nil {
		return
	}
	value = MSAcctAuthType(i)
	return
}

func MSAcctAuthType_Set(p *radius.Packet, value MSAcctAuthType) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Set(MSAcctAuthType_Type, a)
	return nil
}

type MSAcctEAPType uint32

const (
	MSAcctEAPType_Value_MD5              MSAcctEAPType = 4
	MSAcctEAPType_Value_OTP              MSAcctEAPType = 5
	MSAcctEAPType_Value_GenericTokenCard MSAcctEAPType = 6
	MSAcctEAPType_Value_TLS              MSAcctEAPType = 13
)

var MSAcctEAPType_Strings = map[MSAcctEAPType]string{
	MSAcctEAPType_Value_MD5:              "MD5",
	MSAcctEAPType_Value_OTP:              "OTP",
	MSAcctEAPType_Value_GenericTokenCard: "Generic-Token-Card",
	MSAcctEAPType_Value_TLS:              "TLS",
}

func (a MSAcctEAPType) String() string {
	if str, ok := MSAcctEAPType_Strings[a]; ok {
		return str
	}
	return "MSAcctEAPType(" + strconv.FormatUint(uint64(a), 10) + ")"
}

func MSAcctEAPType_Add(p *radius.Packet, value MSAcctEAPType) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Add(MSAcctEAPType_Type, a)
	return nil
}

func MSAcctEAPType_Get(p *radius.Packet) (value MSAcctEAPType) {
	value, _ = MSAcctEAPType_Lookup(p)
	return
}

func MSAcctEAPType_Gets(p *radius.Packet) (values []MSAcctEAPType, err error) {
	var i uint32
	for _, attr := range p.Attributes[MSAcctEAPType_Type] {
		i, err = radius.Integer(attr)
		if err != nil {
			return
		}
		values = append(values, MSAcctEAPType(i))
	}
	return
}

func MSAcctEAPType_Lookup(p *radius.Packet) (value MSAcctEAPType, err error) {
	a, ok := p.Lookup(MSAcctEAPType_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	var i uint32
	i, err = radius.Integer(a)
	if err != nil {
		return
	}
	value = MSAcctEAPType(i)
	return
}

func MSAcctEAPType_Set(p *radius.Packet, value MSAcctEAPType) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Set(MSAcctEAPType_Type, a)
	return nil
}

func MSCHAP2Response_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(MSCHAP2Response_Type, a)
	return nil
}

func MSCHAP2Response_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(MSCHAP2Response_Type, a)
	return nil
}

func MSCHAP2Response_Get(p *radius.Packet) (value []byte) {
	value, _ = MSCHAP2Response_Lookup(p)
	return
}

func MSCHAP2Response_GetString(p *radius.Packet) (value string) {
	return string(MSCHAP2Response_Get(p))
}

func MSCHAP2Response_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, attr := range p.Attributes[MSCHAP2Response_Type] {
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAP2Response_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, attr := range p.Attributes[MSCHAP2Response_Type] {
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAP2Response_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(MSCHAP2Response_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func MSCHAP2Response_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(MSCHAP2Response_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func MSCHAP2Response_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(MSCHAP2Response_Type, a)
	return
}

func MSCHAP2Response_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(MSCHAP2Response_Type, a)
	return
}

func MSCHAP2Success_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(MSCHAP2Success_Type, a)
	return nil
}

func MSCHAP2Success_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(MSCHAP2Success_Type, a)
	return nil
}

func MSCHAP2Success_Get(p *radius.Packet) (value []byte) {
	value, _ = MSCHAP2Success_Lookup(p)
	return
}

func MSCHAP2Success_GetString(p *radius.Packet) (value string) {
	return string(MSCHAP2Success_Get(p))
}

func MSCHAP2Success_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, attr := range p.Attributes[MSCHAP2Success_Type] {
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAP2Success_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, attr := range p.Attributes[MSCHAP2Success_Type] {
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAP2Success_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(MSCHAP2Success_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func MSCHAP2Success_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(MSCHAP2Success_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func MSCHAP2Success_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(MSCHAP2Success_Type, a)
	return
}

func MSCHAP2Success_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(MSCHAP2Success_Type, a)
	return
}

func MSCHAP2CPW_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(MSCHAP2CPW_Type, a)
	return nil
}

func MSCHAP2CPW_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(MSCHAP2CPW_Type, a)
	return nil
}

func MSCHAP2CPW_Get(p *radius.Packet) (value []byte) {
	value, _ = MSCHAP2CPW_Lookup(p)
	return
}

func MSCHAP2CPW_GetString(p *radius.Packet) (value string) {
	return string(MSCHAP2CPW_Get(p))
}

func MSCHAP2CPW_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, attr := range p.Attributes[MSCHAP2CPW_Type] {
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAP2CPW_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, attr := range p.Attributes[MSCHAP2CPW_Type] {
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSCHAP2CPW_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(MSCHAP2CPW_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func MSCHAP2CPW_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(MSCHAP2CPW_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func MSCHAP2CPW_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(MSCHAP2CPW_Type, a)
	return
}

func MSCHAP2CPW_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(MSCHAP2CPW_Type, a)
	return
}

func MSPrimaryDNSServer_Add(p *radius.Packet, value net.IP) (err error) {
	var a radius.Attribute
	a, err = radius.NewIPAddr(value)
	if err != nil {
		return
	}
	p.Add(MSPrimaryDNSServer_Type, a)
	return nil
}

func MSPrimaryDNSServer_Get(p *radius.Packet) (value net.IP) {
	value, _ = MSPrimaryDNSServer_Lookup(p)
	return
}

func MSPrimaryDNSServer_Gets(p *radius.Packet) (values []net.IP, err error) {
	var i net.IP
	for _, attr := range p.Attributes[MSPrimaryDNSServer_Type] {
		i, err = radius.IPAddr(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSPrimaryDNSServer_Lookup(p *radius.Packet) (value net.IP, err error) {
	a, ok := p.Lookup(MSPrimaryDNSServer_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value, err = radius.IPAddr(a)
	return
}

func MSPrimaryDNSServer_Set(p *radius.Packet, value net.IP) (err error) {
	var a radius.Attribute
	a, err = radius.NewIPAddr(value)
	if err != nil {
		return
	}
	p.Set(MSPrimaryDNSServer_Type, a)
	return nil
}

func MSSecondaryDNSServer_Add(p *radius.Packet, value net.IP) (err error) {
	var a radius.Attribute
	a, err = radius.NewIPAddr(value)
	if err != nil {
		return
	}
	p.Add(MSSecondaryDNSServer_Type, a)
	return nil
}

func MSSecondaryDNSServer_Get(p *radius.Packet) (value net.IP) {
	value, _ = MSSecondaryDNSServer_Lookup(p)
	return
}

func MSSecondaryDNSServer_Gets(p *radius.Packet) (values []net.IP, err error) {
	var i net.IP
	for _, attr := range p.Attributes[MSSecondaryDNSServer_Type] {
		i, err = radius.IPAddr(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSSecondaryDNSServer_Lookup(p *radius.Packet) (value net.IP, err error) {
	a, ok := p.Lookup(MSSecondaryDNSServer_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value, err = radius.IPAddr(a)
	return
}

func MSSecondaryDNSServer_Set(p *radius.Packet, value net.IP) (err error) {
	var a radius.Attribute
	a, err = radius.NewIPAddr(value)
	if err != nil {
		return
	}
	p.Set(MSSecondaryDNSServer_Type, a)
	return nil
}

func MSPrimaryNBNSServer_Add(p *radius.Packet, value net.IP) (err error) {
	var a radius.Attribute
	a, err = radius.NewIPAddr(value)
	if err != nil {
		return
	}
	p.Add(MSPrimaryNBNSServer_Type, a)
	return nil
}

func MSPrimaryNBNSServer_Get(p *radius.Packet) (value net.IP) {
	value, _ = MSPrimaryNBNSServer_Lookup(p)
	return
}

func MSPrimaryNBNSServer_Gets(p *radius.Packet) (values []net.IP, err error) {
	var i net.IP
	for _, attr := range p.Attributes[MSPrimaryNBNSServer_Type] {
		i, err = radius.IPAddr(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSPrimaryNBNSServer_Lookup(p *radius.Packet) (value net.IP, err error) {
	a, ok := p.Lookup(MSPrimaryNBNSServer_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value, err = radius.IPAddr(a)
	return
}

func MSPrimaryNBNSServer_Set(p *radius.Packet, value net.IP) (err error) {
	var a radius.Attribute
	a, err = radius.NewIPAddr(value)
	if err != nil {
		return
	}
	p.Set(MSPrimaryNBNSServer_Type, a)
	return nil
}

func MSSecondaryNBNSServer_Add(p *radius.Packet, value net.IP) (err error) {
	var a radius.Attribute
	a, err = radius.NewIPAddr(value)
	if err != nil {
		return
	}
	p.Add(MSSecondaryNBNSServer_Type, a)
	return nil
}

func MSSecondaryNBNSServer_Get(p *radius.Packet) (value net.IP) {
	value, _ = MSSecondaryNBNSServer_Lookup(p)
	return
}

func MSSecondaryNBNSServer_Gets(p *radius.Packet) (values []net.IP, err error) {
	var i net.IP
	for _, attr := range p.Attributes[MSSecondaryNBNSServer_Type] {
		i, err = radius.IPAddr(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func MSSecondaryNBNSServer_Lookup(p *radius.Packet) (value net.IP, err error) {
	a, ok := p.Lookup(MSSecondaryNBNSServer_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value, err = radius.IPAddr(a)
	return
}

func MSSecondaryNBNSServer_Set(p *radius.Packet, value net.IP) (err error) {
	var a radius.Attribute
	a, err = radius.NewIPAddr(value)
	if err != nil {
		return
	}
	p.Set(MSSecondaryNBNSServer_Type, a)
	return nil
}

func _Microsoft_AddVendor(p *radius.Packet, typ byte, attr radius.Attribute) (err error) {
	var vsa radius.Attribute
	vendor := make(radius.Attribute, 2+len(attr))
	vendor[0] = typ
	vendor[1] = byte(len(vendor))
	copy(vendor[2:], attr)
	vsa, err = radius.NewVendorSpecific(_Microsoft_VendorID, vendor)
	if err != nil {
		return
	}
	p.Add(rfc2865.VendorSpecific_Type, vsa)
	return nil
}

func _Microsoft_GetsVendor(p *radius.Packet, typ byte) (values []radius.Attribute) {
	for _, attr := range p.Attributes[rfc2865.VendorSpecific_Type] {
		vendorID, vsa, err := radius.VendorSpecific(attr)
		if err != nil || vendorID != _Microsoft_VendorID {
			continue
		}
		for len(vsa) >= 3 {
			vsaTyp, vsaLen := vsa[0], vsa[1]
			if int(vsaLen) > len(vsa) || vsaLen < 3 {
				break
			}
			if vsaTyp == typ {
				values = append(values, vsa[2:int(vsaLen)])
			}
			vsa = vsa[int(vsaLen):]
		}
	}
	return
}

func _Microsoft_LookupVendor(p *radius.Packet, typ byte) (attr radius.Attribute, ok bool) {
	for _, a := range p.Attributes[rfc2865.VendorSpecific_Type] {
		vendorID, vsa, err := radius.VendorSpecific(a)
		if err != nil || vendorID != _Microsoft_VendorID {
			continue
		}
		for len(vsa) >= 3 {
			vsaTyp, vsaLen := vsa[0], vsa[1]
			if int(vsaLen) > len(vsa) || vsaLen < 3 {
				break
			}
			if vsaTyp == typ {
				return vsa[2:int(vsaLen)], true
			}
			vsa = vsa[int(vsaLen):]
		}
	}
	return nil, false
}

func _Microsoft_SetVendor(p *radius.Packet, typ byte, attr radius.Attribute) (err error) {
	for i := 0; i < len(p.Attributes[rfc2865.VendorSpecific_Type]); {
		vendorID, vsa, err := radius.VendorSpecific(p.Attributes[rfc2865.VendorSpecific_Type][i])
		if err != nil || vendorID != _Microsoft_VendorID {
			i++
			continue
		}
		for j := 0; len(vsa[j:]) >= 3; {
			vsaTyp, vsaLen := vsa[0], vsa[1]
			if int(vsaLen) > len(vsa[j:]) || vsaLen < 3 {
				i++
				break
			}
			if vsaTyp == typ {
				vsa = append(vsa[:j], vsa[j+int(vsaLen):]...)
			}
			j += int(vsaLen)
		}
		if len(vsa) > 0 {
			copy(p.Attributes[rfc2865.VendorSpecific_Type][i][4:], vsa)
			i++
		} else {
			p.Attributes[rfc2865.VendorSpecific_Type] = append(p.Attributes[rfc2865.VendorSpecific_Type][:i], p.Attributes[rfc2865.VendorSpecific_Type][i+i:]...)
		}
	}
	return _Microsoft_AddVendor(p, typ, attr)
}
